#![allow(unknown_lints)]
#![allow(unreadable_literal)]

extern crate byteorder;
extern crate rand;
extern crate xoroshiro;

use byteorder::{ByteOrder, LittleEndian};
use rand::{Rng, SeedableRng};
use xoroshiro::rng::{
    SplitMix64,
    XoroShiro128,
    XorShift1024, XorShift1024Seed
};

#[test]
fn splitmix64() {
    let seed: u64 = 1477776061723855037;
    let expected: Vec<u64> = vec![
        1985237415132408290,
        2979275885539914483,
        13511426838097143398,
        8488337342461049707,
        15141737807933549159,
        17093170987380407015,
        16389528042912955399,
        13177319091862933652,
        10841969400225389492,
        17094824097954834098,
        3336622647361835228,
        9678412372263018368,
        11111587619974030187,
        7882215801036322410,
        5709234165213761869,
        7799681907651786826,
        4616320717312661886,
        4251077652075509767,
        7836757050122171900,
        5054003328188417616,
        12919285918354108358,
        16477564761813870717,
        5124667218451240549,
        18099554314556827626,
        7603784838804469118,
        6358551455431362471,
        3037176434532249502,
        3217550417701719149,
        9958699920490216947,
        5965803675992506258,
        12000828378049868312,
        12720568162811471118,
        245696019213873792,
        8351371993958923852,
        14378754021282935786,
        5655432093647472106,
        5508031680350692005,
        8515198786865082103,
        6287793597487164412,
        14963046237722101617,
        3630795823534910476,
        8422285279403485710,
        10554287778700714153,
        10871906555720704584,
        8659066966120258468,
        9420238805069527062,
        10338115333623340156,
        13514802760105037173,
        14635952304031724449,
        15419692541594102413,
    ];

    let mut rng = SplitMix64::from_seed_u64(seed);
    for (i, &j) in rng.gen_iter::<u64>().zip(expected.iter()) {
        assert_eq!(i, j);
    }
}

#[test]
fn xoroshiro128() {
    let seed_u64: u64 = 1477776328140003287;
    let mut seed = [0; 16];
    for i in 0..2 {
        LittleEndian::write_u64(&mut seed[i*8..(i + 1)*8], seed_u64);
    }
    let expected: Vec<u64> = vec![
        2955552656280006574,
        16972449677822927371,
        7745721154813139207,
        12997958984192882321,
        4860378213520716854,
        8726511682199311786,
        4967513430844037468,
        8198976591537859742,
        9550424487982531115,
        4998682132896022152,
        13530700387126949659,
        4863306358944123927,
        6496460551288602950,
        6300357993177847246,
        12981686428016233582,
        12822865705859271257,
        2796743621789288691,
        8661416515684566800,
        11445987918223307471,
        1790853738844129809,
        2512856687931852193,
        16961358987206987195,
        16831923336886883616,
        1799620397890053848,
        4161295844397818624,
        11706748128305355888,
        12617353356118917788,
        8547805800213650247,
        10603793685490426181,
        2685147166973982615,
        11631827950742619990,
        17869005055181116877,
        2020111105125139909,
        16554904763398876336,
        9181122027598760409,
        9525691846569931390,
        12672329911556000760,
        1151541992527799435,
        4599060499520055258,
        221771256380528480,
        1278551507256768851,
        6765526366205621730,
        17926663798966796569,
        2326731362433357863,
        3573739488452626027,
        12112678412767368200,
        11945823449132469584,
        18281508020577789940,
        17522627411608091340,
        6715575954761285513
    ];

    let mut rng = XoroShiro128::from_seed(seed);
    for (i, &j) in rng.gen_iter::<u64>().zip(expected.iter()) {
        assert_eq!(i, j);
    }
}

#[test]
fn xorshift1024() {
    let seed_u64: u64 = 1477777179826044140;
    let mut seed = [0; 128];
    for i in 0..16 {
        LittleEndian::write_u64(&mut seed[i*8..(i + 1)*8], seed_u64);
    }
    let expected: Vec<u64> = vec![
        10769172823028838824,
        158748326494619566,
        208724771792468224,
        15082597074723100036,
        10769172823028838824,
        158748326494619566,
        208724771792468224,
        15082597074723100036,
        10769172823028838824,
        158748326494619566,
        208724771792468224,
        15082597074723100036,
        10769172823028838824,
        158748326494619566,
        208724771792468224,
        15082597074723100036,
        4785831406125245938,
        3707589112586910408,
        15720884992910529436,
        4070790469854541867,
        18178419009908218870,
        4310394285307449415,
        208724771792468224,
        15082597074723100036,
        4785831406125245938,
        3707589112586910408,
        15720884992910529436,
        4070790469854541867,
        18178419009908218870,
        4310394285307449415,
        208724771792468224,
        15082597074723100036,
        18344437035021906358,
        16922873730164827166,
        2633962190917692431,
        7204127042688143700,
        5123218758229241267,
        4310394285307449415,
        208724771792468224,
        15082597074723100036,
        18344437035021906358,
        16922873730164827166,
        2633962190917692431,
        7204127042688143700,
        5123218758229241267,
        4310394285307449415,
        208724771792468224,
        15082597074723100036,
        11228527644557025309,
        13964547572092459124,
    ];

    let mut rng = XorShift1024::from_seed(XorShift1024Seed(seed));
    for (i, &j) in rng.gen_iter::<u64>().zip(expected.iter()) {
        assert_eq!(i, j);
    }
}

#[test]
fn bool_xoroshiro() {
    let mut rng = XoroShiro128::from_seed_u64(1234);
    let mut trues = 0;
    let mut falses = 0;
    for _ in 0..10000000 {
        let b: bool = rng.gen();
        if b {
            trues += 1;
        } else {
            falses += 1;
        }
    }
    let ratio = (trues as f64) / ((trues + falses) as f64);
    println!("{}", ratio);
    assert!((ratio - 0.5) < 1e-4);
}
